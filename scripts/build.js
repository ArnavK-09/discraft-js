import fs from"fs";import path from"path";import{info,error,success}from"../common/utils/logger.js";import inquirer from"inquirer";import{rollup}from"rollup";import{getFileSizes,displaySizeComparison}from"./utils/fileSizeUtil.js";import{minifyWithTerser}from"./utils/minifyUtilTerser.js";import generateCommands from"./compile/genCommands.js";import generateEvents from"./compile/genEvents.js";import{nodeResolve}from"@rollup/plugin-node-resolve";import commonjs from"@rollup/plugin-commonjs";import json from"@rollup/plugin-json";import replace from"@rollup/plugin-replace";import babel from"@rollup/plugin-babel";import{fileURLToPath}from"url";const __filename=fileURLToPath(import.meta.url),__dirname=path.dirname(__filename),discraftDir=path.resolve(__dirname,".."),projectDir=process.cwd(),srcDir=path.join(projectDir,"src");let buildInProgress=!1,currentBundle=null;async function analyzeDependencies(e,i){const r=new Set;for(const e of i.output){const i=Array.isArray(e.output)?e.output:[e];for(const e of i)e.imports&&e.imports.forEach((e=>r.add(e)))}const n={name:"discraft-bot",type:"module",version:"1.0.0",description:"Bot created with Discraft",main:"bundle.js",dependencies:{}};return r.forEach((e=>{n.dependencies[e]="latest"})),info(`Found ${r.size} external dependencies.`),n}async function build(e){buildInProgress=!0;try{if(info("Starting build process..."),!fs.existsSync(srcDir))throw new Error(`Source directory not found at ${srcDir}`);const i=path.join(srcDir,"index.js");if(!fs.existsSync(i))throw new Error(`Entry point not found at ${i}`);info("Generating commands and events..."),await new Promise((e=>{generateCommands(srcDir),generateEvents(srcDir),e()}));const r=await getBuildConfig(e),n=Date.now(),t=await getFileSizes(srcDir),o=path.resolve(projectDir,e.output);fs.existsSync(o)&&await fs.promises.rm(o,{recursive:!0}),await fs.promises.mkdir(o,{recursive:!0});const s=path.join(discraftDir,"node_modules","@babel/preset-env"),a={input:i,output:{file:path.join(o,"bundle.js"),format:"es",exports:"auto",minifyInternalExports:!0},external:e=>!(e.startsWith(".")||e.startsWith("/")||e.startsWith("src/")||e.startsWith("../")||e.startsWith("./")),plugins:[replace({preventAssignment:!0,"process.env.NODE_ENV":JSON.stringify("production")}),nodeResolve({preferBuiltins:!0,exportConditions:["node"]}),commonjs({ignoreDynamicRequires:!1}),json(),babel({babelHelpers:"bundled",configFile:!1,babelrc:!1,presets:[[s,{targets:{node:"current"},modules:!1,loose:!0,exclude:["transform-typeof-symbol"]}]]})],treeshake:{moduleSideEffects:!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1}};info("Running Rollup bundler...");const l=await rollup(a);currentBundle=l;const m=await l.write(a.output);await l.close(),currentBundle=null;const c=path.join(o,"bundle.js");if(!fs.existsSync(c))throw new Error(`Bundle file not created at ${c}`);info("Analyzing dependencies...");const p=await analyzeDependencies(c,{output:[m]});await fs.promises.writeFile(path.join(o,"package.json"),JSON.stringify(p,null,2)),info("Generated minimal package.json in dist directory"),r.minify&&(info("Running Terser minification..."),r.maxOptimize&&info("Using maximum optimization settings (this may take longer)..."),await minifyWithTerser(c,r)),await displaySizeComparison(t,o),info(`Output location: ${o}`),success("Build completed successfully in "+(Date.now()-n)+"ms")}catch(e){error("Build failed:",e),process.exit(1)}finally{buildInProgress=!1,currentBundle=null}}async function getBuildConfig(e){return e.yes?{minify:!0,keepFunctionNames:!1,removeComments:!0,sourceMaps:!1,maxOptimize:e.maxOptimize}:inquirer.prompt([{type:"confirm",name:"minify",message:"Do you want to minify the code?",default:!0},{type:"confirm",name:"maxOptimize",message:"Enable maximum optimization (slower build, faster runtime)?",default:!0,when:e=>e.minify},{type:"confirm",name:"keepFunctionNames",message:"Keep function names for better error traces? (disable for smaller size)",default:!1,when:e=>e.minify},{type:"confirm",name:"removeComments",message:"Remove comments from the output?",default:!0,when:e=>e.minify},{type:"confirm",name:"sourceMaps",message:"Generate source maps?",default:!1,when:e=>e.minify}])}process.on("SIGINT",(async()=>{if(buildInProgress){info("\nGracefully cancelling build process...");try{currentBundle&&await currentBundle.close();const e=path.resolve(projectDir,"dist");fs.existsSync(e)&&await fs.promises.rm(e,{recursive:!0}),info("Build cancelled and cleaned up successfully.")}catch(e){error("Error while cleaning up:",e)}}process.exit(0)}));const options={yes:process.argv.includes("-y")||process.argv.includes("--yes"),output:process.argv.includes("-o")?process.argv[process.argv.indexOf("-o")+1]:"dist",maxOptimize:process.argv.includes("--max-optimize")};build(options);