import fs from"fs";import path from"path";import{info,error,success,log}from"../common/utils/logger.js";import{checkbox,confirm}from"@inquirer/prompts";import{rollup}from"rollup";import{getFileSizes,displaySizeComparison}from"./utils/fileSizeUtil.js";import{minifyWithTerser}from"./utils/minifyUtilTerser.js";import generateCommands from"./compile/genCommands.js";import generateEvents from"./compile/genEvents.js";import{nodeResolve}from"@rollup/plugin-node-resolve";import commonjs from"@rollup/plugin-commonjs";import json from"@rollup/plugin-json";import replace from"@rollup/plugin-replace";import babel from"@rollup/plugin-babel";import{exec}from"child_process";const projectDir=process.cwd(),srcDir=path.join(projectDir,"src");let buildInProgress=!1,currentBundle=null;async function analyzeDependencies(e,n){const o=new Set;for(const e of n.output){const n=Array.isArray(e.output)?e.output:[e];for(const e of n)e.imports&&e.imports.forEach((e=>o.add(e)))}const r={name:"discraft-bot",type:"module",version:"1.0.0",description:"Bot created with Discraft",main:"bundle.js",dependencies:{}};return o.forEach((e=>{r.dependencies[e]="latest"})),info(`Found ${o.size} external dependencies.`),r}async function build(e){buildInProgress=!0;try{if(info("Starting build process..."),!fs.existsSync(srcDir))throw new Error(`Source directory not found at ${srcDir}`);const n=path.join(srcDir,"index.js");if(!fs.existsSync(n))throw new Error(`Entry point not found at ${n}`);info("Generating commands and events..."),await new Promise((e=>{generateCommands(srcDir),generateEvents(srcDir),e()}));const o=await getBuildConfig(e),r=Date.now(),i=await getFileSizes(srcDir),s=path.resolve(projectDir,e.output);fs.existsSync(s)&&await fs.promises.rm(s,{recursive:!0}),await fs.promises.mkdir(s,{recursive:!0});const t={input:n,output:{file:path.join(s,"bundle.js"),format:"es",exports:"auto",minifyInternalExports:!0},external:o.standalone?[]:e=>!(e.startsWith(".")||e.startsWith("/")||e.startsWith("src/")||e.startsWith("../")||e.startsWith("./")),plugins:[replace({preventAssignment:!0,"process.env.NODE_ENV":JSON.stringify("production")}),nodeResolve({preferBuiltins:!0,exportConditions:["node"]}),commonjs({ignoreDynamicRequires:!1}),json(),babel({babelHelpers:"bundled",configFile:!1,babelrc:!1,presets:[["@babel/preset-env",{targets:{node:"current"},modules:!1,loose:!0,exclude:["transform-typeof-symbol"]}]]})],treeshake:{moduleSideEffects:!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1}};if(o.standalone){try{info("Simplifying dependencies (this may take a while)...");const e=await async function(e=6e4){return new Promise(((n,o)=>{const r=exec("npx --yes clean-modules -y",((e,r,i)=>{e?o(e||i):n(r)})),i=setTimeout((()=>{r.kill(),o(new Error(`Process timed out after ${e}ms`))}),e);r.on("close",(()=>clearTimeout(i)))}))}(6e4);log(e)}catch(e){error("Failed to simplify dependencies:",e)}}info("Running Rollup bundler..."),currentBundle=await rollup(t);const a=await currentBundle.write(t.output);await currentBundle.close(),currentBundle=null;const c=path.join(s,"bundle.js");if(!fs.existsSync(c))throw new Error(`Bundle file not created at ${c}`);if(o.standalone)info("Skipping package.json generation (standalone mode)");else{const e=await analyzeDependencies(c,{output:[a]});await fs.promises.writeFile(path.join(s,"package.json"),JSON.stringify(e,null,2)),info("Generated package.json with dependencies")}o.minify&&(info("Running Terser minification..."),o.maxOptimize&&info("Using maximum optimization settings (this may take longer)..."),await minifyWithTerser(c,o)),o.standalone||await displaySizeComparison(i,s),info(`Output location: ${s}`),success("Build completed successfully in "+(Date.now()-r)+"ms")}catch(e){"ExitPromptError"===e.name?error("Build cancelled"):e instanceof Error?error("Build failed or cancelled:",e?.message||e):error("Build failed or cancelled:",e),process.exit(1)}finally{buildInProgress=!1,currentBundle=null}}async function getBuildConfig(e){try{if(e.yes)return{minify:!0,keepFunctionNames:!1,removeComments:!0,sourceMaps:!1,maxOptimize:e.maxOptimize,standalone:e.standalone};console.log("\n");const n=await confirm({message:"Do you want to minify the code?"});let o=[];return n&&(o=await checkbox({message:"Configure Additional Build Options:",choices:[{value:"maxOptimize",name:"Enable maximum optimization",checked:!0},{value:"keepFunctionNames",name:"Keep function names for better error traces",checked:!1},{value:"removeComments",name:"Remove comments from the output",checked:!0},{value:"sourceMaps",name:"Generate source maps",checked:!1},{value:"standalone",name:"Create standalone bundle with all dependencies included",checked:!1}]})),{minify:n,keepFunctionNames:o.includes("keepFunctionNames"),removeComments:o.includes("removeComments"),sourceMaps:o.includes("sourceMaps"),maxOptimize:o.includes("maxOptimize"),standalone:o.includes("standalone")}}catch(e){return"ExitPromptError"===e.name?(error("Build cancelled by user."),process.exit(0)):(error("Error while getting build config:",e),process.exit(1))}}process.on("SIGINT",(async()=>{if(buildInProgress){info("\nGracefully cancelling build process...");try{currentBundle&&await currentBundle.close();const e=path.resolve(projectDir,"dist");fs.existsSync(e)&&await fs.promises.rm(e,{recursive:!0}),info("Build cancelled and cleaned up successfully.")}catch(e){error("Error while cleaning up:",e)}}process.exit(0)}));const options={yes:process.argv.includes("-y")||process.argv.includes("--yes"),output:process.argv.includes("-o")?process.argv[process.argv.indexOf("-o")+1]:process.argv.includes("--output")?process.argv[process.argv.indexOf("--output")+1]:"dist",maxOptimize:process.argv.includes("--max-optimize"),standalone:process.argv.includes("--standalone")};build(options);