import fs from"fs";import path from"path";import{info,error,success}from"../common/utils/logger.js";import inquirer from"inquirer";import{rollup}from"rollup";import{getFileSizes,displaySizeComparison}from"./utils/fileSizeUtil.js";import{minifyWithTerser}from"./utils/minifyUtilTerser.js";import generateCommands from"./compile/genCommands.js";import generateEvents from"./compile/genEvents.js";import{nodeResolve}from"@rollup/plugin-node-resolve";import commonjs from"@rollup/plugin-commonjs";import json from"@rollup/plugin-json";import replace from"@rollup/plugin-replace";import babel from"@rollup/plugin-babel";import{fileURLToPath}from"url";const __filename=fileURLToPath(import.meta.url),__dirname=path.dirname(__filename),discraftDir=path.resolve(__dirname,".."),projectDir=process.cwd(),srcDir=path.join(projectDir,"src");let buildInProgress=!1,currentBundle=null;async function analyzeDependencies(e,r){const n=new Set;for(const e of r.output){const r=Array.isArray(e.output)?e.output:[e];for(const e of r)e.imports&&e.imports.forEach((e=>n.add(e)))}const i={name:"discraft-bot",type:"module",version:"1.0.0",description:"Bot created with Discraft",main:"bundle.js",dependencies:{}};return n.forEach((e=>{i.dependencies[e]="latest"})),info(`Found ${n.size} external dependencies.`),i}async function build(e){buildInProgress=!0;try{if(info("Starting build process..."),!fs.existsSync(srcDir))throw new Error(`Source directory not found at ${srcDir}`);const r=path.join(srcDir,"index.js");if(!fs.existsSync(r))throw new Error(`Entry point not found at ${r}`);info("Generating commands and events..."),await new Promise((e=>{generateCommands(srcDir),generateEvents(srcDir),e()}));const n=await getBuildConfig(e),i=Date.now(),t=await getFileSizes(srcDir),o=path.resolve(projectDir,e.output);fs.existsSync(o)&&await fs.promises.rm(o,{recursive:!0}),await fs.promises.mkdir(o,{recursive:!0});const s=path.join(discraftDir,"node_modules","@babel/preset-env"),a={input:r,output:{file:path.join(o,"bundle.js"),format:"es",exports:"auto",minifyInternalExports:!0},external:n.standalone?[]:e=>!(e.startsWith(".")||e.startsWith("/")||e.startsWith("src/")||e.startsWith("../")||e.startsWith("./")),plugins:[replace({preventAssignment:!0,"process.env.NODE_ENV":JSON.stringify("production")}),nodeResolve({preferBuiltins:!0,exportConditions:["node"]}),commonjs({ignoreDynamicRequires:!1}),json(),babel({babelHelpers:"bundled",configFile:!1,babelrc:!1,presets:[[s,{targets:{node:"current"},modules:!1,loose:!0,exclude:["transform-typeof-symbol"]}]]})],treeshake:{moduleSideEffects:!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1}};info("Running Rollup bundler..."),currentBundle=await rollup(a);const l=await currentBundle.write(a.output);await currentBundle.close(),currentBundle=null;const c=path.join(o,"bundle.js");if(!fs.existsSync(c))throw new Error(`Bundle file not created at ${c}`);if(n.standalone)info("Skipping package.json generation (standalone mode)");else{const e=await analyzeDependencies(c,{output:[l]});await fs.promises.writeFile(path.join(o,"package.json"),JSON.stringify(e,null,2)),info("Generated package.json with dependencies")}n.minify&&(info("Running Terser minification..."),n.maxOptimize&&info("Using maximum optimization settings (this may take longer)..."),await minifyWithTerser(c,n)),n.standalone||await displaySizeComparison(t,o),info(`Output location: ${o}`),success("Build completed successfully in "+(Date.now()-i)+"ms")}catch(e){"ExitPromptError"===e.name?error("Build cancelled"):e instanceof Error?error("Build failed or cancelled:",e?.message||e):error("Build failed or cancelled:",e),process.exit(1)}finally{buildInProgress=!1,currentBundle=null}}async function getBuildConfig(e){try{return e.yes?{minify:!0,keepFunctionNames:!1,removeComments:!0,sourceMaps:!1,maxOptimize:e.maxOptimize,standalone:e.standalone}:inquirer.prompt([{type:"confirm",name:"minify",message:"Do you want to minify the code?",default:!0},{type:"confirm",name:"maxOptimize",message:"Enable maximum optimization?",default:!0,when:e=>e.minify},{type:"confirm",name:"keepFunctionNames",message:"Keep function names for better error traces?",default:!1,when:e=>e.minify},{type:"confirm",name:"removeComments",message:"Remove comments from the output?",default:!0,when:e=>e.minify},{type:"confirm",name:"sourceMaps",message:"Generate source maps?",default:!1,when:e=>e.minify},{type:"confirm",name:"standalone",message:"Create standalone bundle with all dependencies included?",default:!1}])}catch(e){return"ExitPromptError"===e.name?(error("Build cancelled by user."),process.exit(0)):(error("Error while getting build config:",e),process.exit(1))}}process.on("SIGINT",(async()=>{if(buildInProgress){info("\nGracefully cancelling build process...");try{currentBundle&&await currentBundle.close();const e=path.resolve(projectDir,"dist");fs.existsSync(e)&&await fs.promises.rm(e,{recursive:!0}),info("Build cancelled and cleaned up successfully.")}catch(e){error("Error while cleaning up:",e)}}process.exit(0)}));const options={yes:process.argv.includes("-y")||process.argv.includes("--yes"),output:process.argv.includes("-o")?process.argv[process.argv.indexOf("-o")+1]:"dist",maxOptimize:process.argv.includes("--max-optimize"),standalone:process.argv.includes("--standalone")};build(options);