import fs from"fs";import path from"path";import{info,error,success,log}from"../common/utils/logger.js";import{checkbox,confirm}from"@inquirer/prompts";import{rollup}from"rollup";import{getFileSizes,displaySizeComparison}from"./utils/fileSizeUtil.js";import{minifyWithTerser}from"./utils/minifyUtilTerser.js";import generateCommands from"./compile/genCommands.js";import generateEvents from"./compile/genEvents.js";import{nodeResolve}from"@rollup/plugin-node-resolve";import commonjs from"@rollup/plugin-commonjs";import json from"@rollup/plugin-json";import replace from"@rollup/plugin-replace";import babel from"@rollup/plugin-babel";import{fileURLToPath}from"url";import{exec}from"child_process";const __filename=fileURLToPath(import.meta.url),__dirname=path.dirname(__filename),discraftDir=path.resolve(__dirname,".."),projectDir=process.cwd(),srcDir=path.join(projectDir,"src");let buildInProgress=!1,currentBundle=null;async function analyzeDependencies(bundlePath,rollupBundle){const externalDeps=new Set;for(const item of rollupBundle.output){const chunks=Array.isArray(item.output)?item.output:[item];for(const chunk of chunks)chunk.imports&&chunk.imports.forEach((imp=>externalDeps.add(imp)))}const minimalPackage={name:"discraft-bot",type:"module",version:"1.0.0",description:"Bot created with Discraft",main:"bundle.js",dependencies:{}};return externalDeps.forEach((dep=>{minimalPackage.dependencies[dep]="latest"})),info(`Found ${externalDeps.size} external dependencies.`),minimalPackage}async function build(options){buildInProgress=!0;try{if(info("Starting build process..."),!fs.existsSync(srcDir))throw new Error(`Source directory not found at ${srcDir}`);const inputFile=path.join(srcDir,"index.js");if(!fs.existsSync(inputFile))throw new Error(`Entry point not found at ${inputFile}`);info("Generating commands and events..."),await new Promise((resolve=>{generateCommands(srcDir),generateEvents(srcDir),resolve()}));const config=await getBuildConfig(options),startTime=Date.now(),originalSize=await getFileSizes(srcDir),outputDir=path.resolve(projectDir,options.output);fs.existsSync(outputDir)&&await fs.promises.rm(outputDir,{recursive:!0}),await fs.promises.mkdir(outputDir,{recursive:!0});const presetEnvPath=path.join(discraftDir,"node_modules","@babel/preset-env"),rollupConfig={input:inputFile,output:{file:path.join(outputDir,"bundle.js"),format:"es",exports:"auto",minifyInternalExports:!0},external:config.standalone?[]:id=>!(id.startsWith(".")||id.startsWith("/")||id.startsWith("src/")||id.startsWith("../")||id.startsWith("./")),plugins:[replace({preventAssignment:!0,"process.env.NODE_ENV":JSON.stringify("production")}),nodeResolve({preferBuiltins:!0,exportConditions:["node"]}),commonjs({ignoreDynamicRequires:!1}),json(),babel({babelHelpers:"bundled",configFile:!1,babelrc:!1,presets:[[presetEnvPath,{targets:{node:"current"},modules:!1,loose:!0,exclude:["transform-typeof-symbol"]}]]})],treeshake:{moduleSideEffects:!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1}};if(config.standalone){try{info("Simplifying dependencies (this may take a while)...");const result=await async function(timeout=6e4){return new Promise(((resolve,reject)=>{const process=exec("npx --yes clean-modules -y",((error,stdout,stderr)=>{error?reject(error||stderr):resolve(stdout)})),timeoutId=setTimeout((()=>{process.kill(),reject(new Error(`Process timed out after ${timeout}ms`))}),timeout);process.on("close",(()=>clearTimeout(timeoutId)))}))}(6e4);log(result)}catch(err){error("Failed to simplify dependencies:",err)}}info("Running Rollup bundler..."),currentBundle=await rollup(rollupConfig);const bundle=await currentBundle.write(rollupConfig.output);await currentBundle.close(),currentBundle=null;const bundlePath=path.join(outputDir,"bundle.js");if(!fs.existsSync(bundlePath))throw new Error(`Bundle file not created at ${bundlePath}`);if(config.standalone)info("Skipping package.json generation (standalone mode)");else{const packageJson=await analyzeDependencies(bundlePath,{output:[bundle]});await fs.promises.writeFile(path.join(outputDir,"package.json"),JSON.stringify(packageJson,null,2)),info("Generated package.json with dependencies")}config.minify&&(info("Running Terser minification..."),config.maxOptimize&&info("Using maximum optimization settings (this may take longer)..."),await minifyWithTerser(bundlePath,config)),config.standalone||await displaySizeComparison(originalSize,outputDir),info(`Output location: ${outputDir}`),success("Build completed successfully in "+(Date.now()-startTime)+"ms")}catch(err){"ExitPromptError"===err.name?error("Build cancelled"):err instanceof Error?error("Build failed or cancelled:",err?.message||err):error("Build failed or cancelled:",err),process.exit(1)}finally{buildInProgress=!1,currentBundle=null}}async function getBuildConfig(options){try{if(options.yes)return{minify:!0,keepFunctionNames:!1,removeComments:!0,sourceMaps:!1,maxOptimize:options.maxOptimize,standalone:options.standalone};console.log("\n");const minify=await confirm({message:"Do you want to minify the code?"});let additionalOptions=[];return minify&&(additionalOptions=await checkbox({message:"Configure Additional Build Options:",choices:[{value:"maxOptimize",name:"Enable maximum optimization",checked:!0},{value:"keepFunctionNames",name:"Keep function names for better error traces",checked:!1},{value:"removeComments",name:"Remove comments from the output",checked:!0},{value:"sourceMaps",name:"Generate source maps",checked:!1},{value:"standalone",name:"Create standalone bundle with all dependencies included",checked:!1}]})),{minify:minify,keepFunctionNames:additionalOptions.includes("keepFunctionNames"),removeComments:additionalOptions.includes("removeComments"),sourceMaps:additionalOptions.includes("sourceMaps"),maxOptimize:additionalOptions.includes("maxOptimize"),standalone:additionalOptions.includes("standalone")}}catch(err){return"ExitPromptError"===err.name?(error("Build cancelled by user."),process.exit(0)):(error("Error while getting build config:",err),process.exit(1))}}process.on("SIGINT",(async()=>{if(buildInProgress){info("\nGracefully cancelling build process...");try{currentBundle&&await currentBundle.close();const outputDir=path.resolve(projectDir,"dist");fs.existsSync(outputDir)&&await fs.promises.rm(outputDir,{recursive:!0}),info("Build cancelled and cleaned up successfully.")}catch(err){error("Error while cleaning up:",err)}}process.exit(0)}));const options={yes:process.argv.includes("-y")||process.argv.includes("--yes"),output:process.argv.includes("-o")?process.argv[process.argv.indexOf("-o")+1]:process.argv.includes("--output")?process.argv[process.argv.indexOf("--output")+1]:"dist",maxOptimize:process.argv.includes("--max-optimize"),standalone:process.argv.includes("--standalone")};build(options);