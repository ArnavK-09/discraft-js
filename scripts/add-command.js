import fs from"fs";import path from"path";import{input,confirm,search,checkbox}from"@inquirer/prompts";import{success,error}from"../common/utils/logger.js";async function generateCommand(){const doesSrcDirExist=fs.existsSync(path.join(process.cwd(),"src")),isSrcDir=process.cwd().endsWith("src");doesSrcDirExist||(isSrcDir?(error('You are in the "src/" directory. You should be in the root of your Discraft project.'),process.exit(1)):(error('The "src/" directory does not exist. Please run "discraft init" to initialize a project, or ensure you are in the root of your Discraft project.'),process.exit(1)));let commandConfig={permissions:[],features:[],options:[]};try{commandConfig.name=await input({message:"Command name:",required:!0,validate:input=>!!/^[a-z]+(-[a-z]+)*$/.test(input)||"Must be lowercase with single dashes only."}),commandConfig.description=await input({message:"Command description:",default:"A Discraft-js Bot Command...",validate:input=>input.length>0})}catch(err){return"ExitPromptError"===err.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",err),process.exit(1))}try{const featuresAnswers=await checkbox({message:"Select command features:",choices:[{name:"Enable command response caching",value:"cacheable",checked:!1},{name:"Use deferred responses",value:"deferred",checked:!1},{name:"Make responses ephemeral (only visible to the command user)",value:"ephemeral",checked:!1},{name:"Add permission requirements",value:"permissions",checked:!1}]});commandConfig.features=featuresAnswers}catch(err){return"ExitPromptError"===err.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",err),process.exit(1))}if(await confirm({message:"Would you like to add command options? (e.g., /command <option>)",default:!1}).catch((err=>"ExitPromptError"===err.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",err),process.exit(1))))){console.log("\nAdding options to your command... For each option, you'll need to specify:"),console.log("- The type of data it accepts (text, number, etc.)"),console.log('- The name of the option (e.g., "user" in /ban <user>)'),console.log("- A description of what the option does\n");let addingOptions=!0;for(;addingOptions;){let optionAnswers={};try{const commandOptionType=await search({message:"What type of data should this option accept?",source:async input=>{const options=[{name:"String (text)",value:"String",description:"A sequence of characters, typically text."},{name:"Integer (whole number)",value:"Integer",description:"A whole number (no decimal places)."},{name:"Number (decimal number)",value:"Number",description:"A number that can include decimals."},{name:"Boolean (true/false)",value:"Boolean",description:"A value that can be either true or false."},{name:"User (Discord user)",value:"User",description:"A Discord user (mentionable or not)."},{name:"Channel (Discord channel)",value:"Channel",description:"A Discord channel (text, voice, etc.)."},{name:"Role (Discord role)",value:"Role",description:"A Discord role that can be assigned to users."},{name:"Mentionable (user or role)",value:"Mentionable",description:"A mentionable user or role."},{name:"Attachment (file)",value:"Attachment",description:"A file attachment (image, document, etc.)."}];return input?options.filter((option=>option.name.toLowerCase().includes(input.toLowerCase())||option.description.toLowerCase().includes(input.toLowerCase()))).map((option=>({name:`${option.name} - ${option.description}`,value:option.value,description:option.description}))):options}}),commandOptionName=await input({message:'Option name (e.g., "user"):',validate:input=>!!/^[a-z0-9-]+$/.test(input)||"Option name must be lowercase and may only contain letters, numbers, and dashes",required:!0}),commandOptionDecription=await input({message:'Option description (e.g., "The user to ban"):',validate:input=>input.length>0,required:!1,default:`Command option accepts ${commandOptionType}`}),commandOptionRequired=await confirm({message:"Is this option required?",default:!1});optionAnswers.type=commandOptionName,optionAnswers.name=commandOptionName,optionAnswers.description=commandOptionDecription,optionAnswers.required=commandOptionRequired}catch(err){return"ExitPromptError"===err.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",err),process.exit(1))}commandConfig.options.push({type:optionAnswers.type.toLowerCase(),name:optionAnswers.name,description:optionAnswers.description,required:optionAnswers.required}),console.log("\n");await confirm({message:"Would you like to add another option?"}).catch((err=>"ExitPromptError"===err.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",err),process.exit(1))))||(addingOptions=!1)}}if(commandConfig.features.includes("permissions")){console.log("\nSelect the permissions required to use this command:");const commandPerms=await checkbox({message:"Required permissions:",choices:[{name:"Administrator",value:"Administrator"},{name:"Manage Server",value:"ManageGuild"},{name:"Manage Messages",value:"ManageMessages"},{name:"Manage Channels",value:"ManageChannels"},{name:"Kick Members",value:"KickMembers"},{name:"Ban Members",value:"BanMembers"},{name:"Send Messages",value:"SendMessages"},{name:"Embed Links",value:"EmbedLinks"},{name:"Attach Files",value:"AttachFiles"},{name:"Read Message History",value:"ReadMessageHistory"},{name:"Mention Everyone",value:"MentionEveryone"}]}).catch((err=>"ExitPromptError"===err.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",err),process.exit(1))));commandConfig.permissions=commandPerms}let commandContent="import { SlashCommandBuilder";commandConfig.permissions.length>0&&(commandContent+=", PermissionFlagsBits"),commandContent+=" } from 'discord.js';\n",commandConfig.features.includes("cacheable")&&(commandContent+="import { commandCache } from '../utils/commandCache.js';\n\n",commandContent+=`// Set command-specific cache settings\ncommandCache.setCommandSettings('${commandConfig.name}', {\n  ttl: 60000, // Cache results for 1 minute\n});\n\n`),commandContent+="export default {\n",commandContent+="  data: new SlashCommandBuilder()\n",commandContent+=`    .setName('${commandConfig.name}')\n`,commandContent+=`    .setDescription('${commandConfig.description}')\n`,commandConfig.options.length>0&&commandConfig.options.forEach((opt=>{commandContent+=`    .add${opt.type.charAt(0).toUpperCase()+opt.type.slice(1)}Option(option =>\n`,commandContent+="      option\n",commandContent+=`        .setName('${opt.name}')\n`,commandContent+=`        .setDescription('${opt.description}')\n`,commandContent+=`        .setRequired(${opt.required})\n`,commandContent+="    )\n"})),commandConfig.permissions.length>0&&commandConfig.permissions.forEach((perm=>{commandContent+=`    .setDefaultMemberPermissions(PermissionFlagsBits.${perm})\n`})),commandContent+="  ,\n\n",commandConfig.features.includes("cacheable")&&(commandContent+="  cacheable: true,\n"),commandContent+="  async execute(interaction) {\n",commandConfig.features.includes("deferred")&&(commandContent+=`    await interaction.deferReply(${commandConfig.features.includes("ephemeral")?"{ ephemeral: true }":""});\n\n`),commandConfig.optionslength>0&&(commandContent+="    // Get command options\n",commandConfig.optins.forEach((opt=>{commandContent+=`    const ${opt.name} = interaction.options.get${opt.type.charAt(0).toUpperCase()+opt.type.slice(1)}('${opt.name}');\n`})),commandContent+="\n"),commandContent+="    // TODO: Add your command logic here\n\n",commandConfig.features.includes("deferred")?commandContent+=`    await interaction.editReply({ content: 'Command executed!' ${commandConfig.features.includes("ephemeral")?", ephemeral: true":""} });\n`:commandContent+=`    await interaction.reply({ content: 'Command executed!' ${commandConfig.features.includes("ephemeral")?", ephemeral: true":""} });\n`,commandContent+="  },\n",commandContent+="};\n";const projectDir=process.cwd(),commandsDir=path.join(projectDir,"src","commands");fs.existsSync(commandsDir)||fs.mkdirSync(commandsDir,{recursive:!0});const filePath=path.join(commandsDir,`${commandConfig.name}.js`);return fs.writeFileSync(filePath,commandContent),success(`Command ${commandConfig.name} created successfully at ${filePath}`),{name:commandConfig.name,path:filePath,features:commandConfig.features,options:commandConfig.options}}generateCommand().catch((err=>{error("Error creating command:",err),process.exit(1)}));