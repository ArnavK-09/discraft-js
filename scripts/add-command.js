import fs from"fs";import path from"path";import{input,confirm,search,checkbox}from"@inquirer/prompts";import{success,error}from"../common/utils/logger.js";async function generateCommand(){const e=fs.existsSync(path.join(process.cwd(),"src")),r=process.cwd().endsWith("src");e||(r?(error('You are in the "src/" directory. You should be in the root of your Discraft project.'),process.exit(1)):(error('The "src/" directory does not exist. Please run "discraft init" to initialize a project, or ensure you are in the root of your Discraft project.'),process.exit(1)));let n={permissions:[],features:[],options:[]};try{n.name=await input({message:"Command name:",required:!0,validate:e=>!!/^[a-z]+(-[a-z]+)*$/.test(e)||"Must be lowercase with single dashes only."}),n.description=await input({message:"Command description:",default:"A Discraft-js Bot Command...",validate:e=>e.length>0})}catch(e){return"ExitPromptError"===e.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",e),process.exit(1))}try{const e=await checkbox({message:"Select command features:",choices:[{name:"Enable command response caching",value:"cacheable",checked:!1},{name:"Use deferred responses",value:"deferred",checked:!1},{name:"Make responses ephemeral (only visible to the command user)",value:"ephemeral",checked:!1},{name:"Add permission requirements",value:"permissions",checked:!1}]});n.features=e}catch(e){return"ExitPromptError"===e.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",e),process.exit(1))}if(await confirm({message:"Would you like to add command options? (e.g., /command <option>)",default:!1}).catch((e=>"ExitPromptError"===e.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",e),process.exit(1))))){console.log("\nAdding options to your command... For each option, you'll need to specify:"),console.log("- The type of data it accepts (text, number, etc.)"),console.log('- The name of the option (e.g., "user" in /ban <user>)'),console.log("- A description of what the option does\n");let e=!0;for(;e;){let r={};try{const e=await search({message:"What type of data should this option accept?",source:async(e,{signal:r})=>{const n=[{name:"String (text)",value:"String",description:"A sequence of characters, typically text."},{name:"Integer (whole number)",value:"Integer",description:"A whole number (no decimal places)."},{name:"Number (decimal number)",value:"Number",description:"A number that can include decimals."},{name:"Boolean (true/false)",value:"Boolean",description:"A value that can be either true or false."},{name:"User (Discord user)",value:"User",description:"A Discord user (mentionable or not)."},{name:"Channel (Discord channel)",value:"Channel",description:"A Discord channel (text, voice, etc.)."},{name:"Role (Discord role)",value:"Role",description:"A Discord role that can be assigned to users."},{name:"Mentionable (user or role)",value:"Mentionable",description:"A mentionable user or role."},{name:"Attachment (file)",value:"Attachment",description:"A file attachment (image, document, etc.)."}];return e?n.filter((r=>r.name.toLowerCase().includes(e.toLowerCase())||r.description.toLowerCase().includes(e.toLowerCase()))).map((e=>({name:`${e.name} - ${e.description}`,value:e.value,description:e.description}))):n}}),n=await input({message:'Option name (e.g., "user"):',validate:e=>!!/^[a-z0-9-]+$/.test(e)||"Option name must be lowercase and may only contain letters, numbers, and dashes",required:!0}),t=await input({message:'Option description (e.g., "The user to ban"):',validate:e=>e.length>0,required:!1,default:`Command option accepts ${e}`}),s=await confirm({message:"Is this option required?",default:!1});r.type=n,r.name=n,r.description=t,r.required=s}catch(e){return"ExitPromptError"===e.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",e),process.exit(1))}n.options.push({type:r.type.toLowerCase(),name:r.name,description:r.description,required:r.required}),console.log("\n");await confirm({message:"Would you like to add another option?"}).catch((e=>"ExitPromptError"===e.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",e),process.exit(1))))||(e=!1)}}if(n.features.includes("permissions")){console.log("\nSelect the permissions required to use this command:");const e=await checkbox({message:"Required permissions:",choices:[{name:"Administrator",value:"Administrator"},{name:"Manage Server",value:"ManageGuild"},{name:"Manage Messages",value:"ManageMessages"},{name:"Manage Channels",value:"ManageChannels"},{name:"Kick Members",value:"KickMembers"},{name:"Ban Members",value:"BanMembers"},{name:"Send Messages",value:"SendMessages"},{name:"Embed Links",value:"EmbedLinks"},{name:"Attach Files",value:"AttachFiles"},{name:"Read Message History",value:"ReadMessageHistory"},{name:"Mention Everyone",value:"MentionEveryone"}]}).catch((e=>"ExitPromptError"===e.name?(error("Cancelled by user."),process.exit(0)):(error("Error:",e),process.exit(1))));n.permissions=e}let t="import { SlashCommandBuilder";n.permissions.length>0&&(t+=", PermissionFlagsBits"),t+=" } from 'discord.js';\n",n.features.includes("cacheable")&&(t+="import { commandCache } from '../utils/commandCache.js';\n\n",t+=`// Set command-specific cache settings\ncommandCache.setCommandSettings('${n.name}', {\n  ttl: 60000, // Cache results for 1 minute\n});\n\n`),t+="export default {\n",t+="  data: new SlashCommandBuilder()\n",t+=`    .setName('${n.name}')\n`,t+=`    .setDescription('${n.description}')\n`,n.options.length>0&&commandOptions.forEach((e=>{t+=`    .add${e.type.charAt(0).toUpperCase()+e.type.slice(1)}Option(option =>\n`,t+="      option\n",t+=`        .setName('${e.name}')\n`,t+=`        .setDescription('${e.description}')\n`,t+=`        .setRequired(${e.required})\n`,t+="    )\n"})),n.permissions.length>0&&n.permissions.forEach((e=>{t+=`    .setDefaultMemberPermissions(PermissionFlagsBits.${e})\n`})),t+="  ,\n\n",n.features.includes("cacheable")&&(t+="  cacheable: true,\n\n"),t+="  async execute(interaction) {\n",n.features.includes("deferred")&&(t+=`    await interaction.deferReply(${n.features.includes("ephemeral")?"{ ephemeral: true }":""});\n\n`),n.options.length>0&&(t+="    // Get command options\n",n.options.forEach((e=>{t+=`    const ${e.name} = interaction.options.get${e.type.charAt(0).toUpperCase()+e.type.slice(1)}('${e.name}');\n`})),t+="\n"),t+="    // TODO: Add your command logic here\n\n",n.features.includes("deferred")?t+=`    await interaction.editReply({ content: 'Command executed!' ${n.features.includes("ephemeral")?", ephemeral: true":""} });\n`:t+=`    await interaction.reply({ content: 'Command executed!' ${n.features.includes("ephemeral")?", ephemeral: true":""} });\n`,t+="  },\n",t+="};\n";const s=process.cwd(),a=path.join(s,"src","commands");fs.existsSync(a)||fs.mkdirSync(a,{recursive:!0});const o=path.join(a,`${n.name}.js`);return fs.writeFileSync(o,t),success(`Command ${n.name} created successfully at ${o}`),{name:n.name,path:o,features:n.features,options:n.options}}generateCommand().catch((e=>{error("Error creating command:",e),process.exit(1)}));