import{Collection,REST,Routes}from"discord.js";import{error,info,debug,success}from"../../utils/logger.js";import{token,clientId}from"../../config/bot.config.js";import{commands}from"./index.js";import{commandCache}from"../../utils/commandCache.js";export class CommandHandler{constructor(client,startTime){this.client=client;this.commands=new Collection;this.commandsData=[];this.setupEventListeners();this.serverStartTime=startTime}setupEventListeners(){this.client.on("interactionCreate",(async interaction=>{if(!interaction.isCommand())return;const command=this.commands.get(interaction.commandName);if(!command)return;try{if(command.cacheable){const cachedResult=commandCache.get(interaction.commandName,interaction.options.data);if(cachedResult){if(cachedResult.steps){await interaction.reply(cachedResult.steps[0]);for(let i=1;i<cachedResult.steps.length;i++){const step=cachedResult.steps[i];if(step.type==="edit"){await interaction.editReply(step.content)}else if(step.type==="followUp"){await interaction.followUp(step.content)}if(i>100){error("Too many steps in cached response!");break}}return}await interaction.reply(cachedResult);return}}const result=await command.execute(interaction);if(command.cacheable&&result){commandCache.set(interaction.commandName,interaction.options.data,result)}}catch(err){error("Error executing command:",err);const content={content:"There was an error executing this command!",ephemeral:true};try{if(interaction.replied||interaction.deferred){await interaction.followUp(content)}else{await interaction.reply(content)}}catch(err){error("Error replying:",err)}}}));this.client.on("guildCreate",(async guild=>{debug(`Bot joined new guild: ${guild.name} (${guild.id})`);await this.registerCommands()}));this.client.once("ready",(async()=>{debug("Registering commands...");await this.registerCommands();info(`Bot is ready as ${this.client.user.tag}`);debug(`Time to register commands: ${Date.now()-this.client.readyTimestamp}ms`);success(`Time to online: ${Date.now()-this.serverStartTime}ms`)}))}async loadCommands(){this.commands.clear();this.commandsData=[];for(const[name,command]of Object.entries(commands)){if("data"in command&&"execute"in command){this.commands.set(command.data.name,command);this.commandsData.push(command.data.toJSON());debug(`Loaded command: ${command.data.name}`)}else{error(`The command ${name} is missing required "data" or "execute" property.`)}}}async registerCommands(){await this.loadCommands();const rest=(new REST).setToken(token);try{debug(`Started refreshing ${this.commandsData.length} application (/) commands.`);const data=await rest.put(Routes.applicationCommands(clientId),{body:this.commandsData});info(`Successfully reloaded ${data.length} application (/) commands.`)}catch(err){error("Error registering commands:",err)}}}